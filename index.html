<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Recorder with Language Selection</title>
    <style>
        .container { max-width: 600px; margin: 20px auto; padding: 20px; }
        button { padding: 10px 20px; margin: 5px; }
        #preview { margin: 20px 0; }
        #result { margin-top: 20px; padding: 10px; border: 1px solid #ddd; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Audio Recorder</h1>

        <!-- Language Selection -->
        <select id="language">
            <option value="hi">Hindi</option>
            <!-- Add other languages as needed -->
        </select>

        <!-- Recording Controls -->
        <div class="controls">
            <button id="recordButton">Start Recording</button>
            <button id="stopButton" disabled>Stop & Upload</button>
        </div>

        <!-- Audio Preview -->
        <audio id="preview" controls></audio>

        <!-- Results Display -->
        <div id="result"></div>
    </div>

    <script>
        const recordButton = document.getElementById('recordButton');
        const stopButton = document.getElementById('stopButton');
        const languageSelect = document.getElementById('language');
        const preview = document.getElementById('preview');
        const resultDiv = document.getElementById('result');

        let mediaStream = null;
        let mediaRecorder;

        // Initialize recording
        recordButton.addEventListener('click', async () => {
            
            let audioChunks = [];
            resultDiv.textContent = '';
            localStorage.removeItem('transcriptions');
            try {
                const stream = await getMediaStream();
                mediaRecorder = new MediaRecorder(stream);

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    preview.src = URL.createObjectURL(audioBlob);
                    const audioContext = new AudioContext();
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    // ENCODE to proper WAV
                    const wavBlob = await encodeWav(audioBuffer);
                    await uploadAudio(wavBlob);
                };

                mediaRecorder.start();
                recordButton.disabled = true;
                stopButton.disabled = false;
            } catch (err) {
                console.error('Error accessing microphone:', err);
            }
        });

        // Stop recording
        stopButton.addEventListener('click', () => {
            mediaRecorder.stop();
            recordButton.disabled = false;
            stopButton.disabled = true;
        });

        // Upload handler
        async function uploadAudio(blob) {
            const formData = new FormData();
            formData.append('file', blob, 'recording.wav');  // Ensure the field name matches the backend's expected name
            formData.append('lang', languageSelect.value);  // Assuming you're passing the language parameter too
            
            
            try {
                const response = await fetch('https://indicconformer-asr-onnx.onrender.com/transcribe', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const result = await response.json();  // Assuming the backend returns JSON
                    resultDiv.textContent = `Server Response: ${result.transcription}`;
                } else {
                    const errorData = await response.json();
                    console.error('Error:', errorData);
                    resultDiv.textContent = 'Error occurred: ' + errorData.detail;
                }
            } catch (error) {
                console.error('Upload failed:', error);
                resultDiv.textContent = 'Upload failed - check console';
            }
        }
        
        async function getMediaStream() {
            if (!mediaStream) {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            }
            return mediaStream;
        }
        
        // Convert AudioBuffer to proper WAV format
        async function encodeWav(audioBuffer) {
            const numChannels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const bytesPerSample = 2; // 16-bit PCM
            const blockAlign = numChannels * bytesPerSample;
            
            const wavHeader = new ArrayBuffer(44);
            const view = new DataView(wavHeader);
            
            // Write WAV header
            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
            
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + audioBuffer.length * blockAlign, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // Subchunk1Size
            view.setUint16(20, 1, true); // PCM format
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bytesPerSample * 8, true);
            writeString(view, 36, 'data');
            view.setUint32(40, audioBuffer.length * blockAlign, true);

            // Merge header and PCM data
            const pcm = new Float32Array(audioBuffer.length * numChannels);
            for (let ch = 0; ch < numChannels; ch++) {
                pcm.set(audioBuffer.getChannelData(ch), ch * audioBuffer.length);
            }
            
            const wavData = new Uint8Array(wavHeader.byteLength + pcm.length * 2);
            wavData.set(new Uint8Array(wavHeader), 0);
            
            // Convert to 16-bit PCM
            const pcm16 = new Int16Array(pcm.length);
            for (let i = 0; i < pcm.length; i++) {
                pcm16[i] = Math.max(-32768, Math.min(32767, pcm[i] * 32767));
            }
            wavData.set(new Uint8Array(pcm16.buffer), 44);
            
            return new Blob([wavData], { type: 'audio/wav' });
        }

    </script>
</body>
</html>
